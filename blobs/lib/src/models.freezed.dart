// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$BlobDataTearOff {
  const _$BlobDataTearOff();

  _BlobData call(
      {int edges = 7,
      int growth = 4,
      double? size,
      BlobPoints? points,
      String? seed,
      Path? path,
      String? svgPath,
      BlobCurves? curves}) {
    return _BlobData(
      edges: edges,
      growth: growth,
      size: size,
      points: points,
      seed: seed,
      path: path,
      svgPath: svgPath,
      curves: curves,
    );
  }
}

/// @nodoc
const $BlobData = _$BlobDataTearOff();

/// @nodoc
mixin _$BlobData {
  int get edges => throw _privateConstructorUsedError;
  int get growth => throw _privateConstructorUsedError;
  double? get size => throw _privateConstructorUsedError;
  BlobPoints? get points => throw _privateConstructorUsedError;
  String? get seed => throw _privateConstructorUsedError;
  Path? get path => throw _privateConstructorUsedError;
  String? get svgPath => throw _privateConstructorUsedError;
  BlobCurves? get curves => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlobDataCopyWith<BlobData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlobDataCopyWith<$Res> {
  factory $BlobDataCopyWith(BlobData value, $Res Function(BlobData) then) =
      _$BlobDataCopyWithImpl<$Res>;
  $Res call(
      {int edges,
      int growth,
      double? size,
      BlobPoints? points,
      String? seed,
      Path? path,
      String? svgPath,
      BlobCurves? curves});

  $BlobPointsCopyWith<$Res>? get points;
  $BlobCurvesCopyWith<$Res>? get curves;
}

/// @nodoc
class _$BlobDataCopyWithImpl<$Res> implements $BlobDataCopyWith<$Res> {
  _$BlobDataCopyWithImpl(this._value, this._then);

  final BlobData _value;
  // ignore: unused_field
  final $Res Function(BlobData) _then;

  @override
  $Res call({
    Object? edges = freezed,
    Object? growth = freezed,
    Object? size = freezed,
    Object? points = freezed,
    Object? seed = freezed,
    Object? path = freezed,
    Object? svgPath = freezed,
    Object? curves = freezed,
  }) {
    return _then(_value.copyWith(
      edges: edges == freezed
          ? _value.edges
          : edges // ignore: cast_nullable_to_non_nullable
              as int,
      growth: growth == freezed
          ? _value.growth
          : growth // ignore: cast_nullable_to_non_nullable
              as int,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      points: points == freezed
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as BlobPoints?,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as Path?,
      svgPath: svgPath == freezed
          ? _value.svgPath
          : svgPath // ignore: cast_nullable_to_non_nullable
              as String?,
      curves: curves == freezed
          ? _value.curves
          : curves // ignore: cast_nullable_to_non_nullable
              as BlobCurves?,
    ));
  }

  @override
  $BlobPointsCopyWith<$Res>? get points {
    if (_value.points == null) {
      return null;
    }

    return $BlobPointsCopyWith<$Res>(_value.points!, (value) {
      return _then(_value.copyWith(points: value));
    });
  }

  @override
  $BlobCurvesCopyWith<$Res>? get curves {
    if (_value.curves == null) {
      return null;
    }

    return $BlobCurvesCopyWith<$Res>(_value.curves!, (value) {
      return _then(_value.copyWith(curves: value));
    });
  }
}

/// @nodoc
abstract class _$BlobDataCopyWith<$Res> implements $BlobDataCopyWith<$Res> {
  factory _$BlobDataCopyWith(_BlobData value, $Res Function(_BlobData) then) =
      __$BlobDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {int edges,
      int growth,
      double? size,
      BlobPoints? points,
      String? seed,
      Path? path,
      String? svgPath,
      BlobCurves? curves});

  @override
  $BlobPointsCopyWith<$Res>? get points;
  @override
  $BlobCurvesCopyWith<$Res>? get curves;
}

/// @nodoc
class __$BlobDataCopyWithImpl<$Res> extends _$BlobDataCopyWithImpl<$Res>
    implements _$BlobDataCopyWith<$Res> {
  __$BlobDataCopyWithImpl(_BlobData _value, $Res Function(_BlobData) _then)
      : super(_value, (v) => _then(v as _BlobData));

  @override
  _BlobData get _value => super._value as _BlobData;

  @override
  $Res call({
    Object? edges = freezed,
    Object? growth = freezed,
    Object? size = freezed,
    Object? points = freezed,
    Object? seed = freezed,
    Object? path = freezed,
    Object? svgPath = freezed,
    Object? curves = freezed,
  }) {
    return _then(_BlobData(
      edges: edges == freezed
          ? _value.edges
          : edges // ignore: cast_nullable_to_non_nullable
              as int,
      growth: growth == freezed
          ? _value.growth
          : growth // ignore: cast_nullable_to_non_nullable
              as int,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      points: points == freezed
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as BlobPoints?,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as Path?,
      svgPath: svgPath == freezed
          ? _value.svgPath
          : svgPath // ignore: cast_nullable_to_non_nullable
              as String?,
      curves: curves == freezed
          ? _value.curves
          : curves // ignore: cast_nullable_to_non_nullable
              as BlobCurves?,
    ));
  }
}

/// @nodoc

class _$_BlobData implements _BlobData {
  const _$_BlobData(
      {this.edges = 7,
      this.growth = 4,
      this.size,
      this.points,
      this.seed,
      this.path,
      this.svgPath,
      this.curves})
      : assert(edges >= 2 && edges <= 300),
        assert(growth >= 2 && growth <= 9);

  @JsonKey(defaultValue: 7)
  @override
  final int edges;
  @JsonKey(defaultValue: 4)
  @override
  final int growth;
  @override
  final double? size;
  @override
  final BlobPoints? points;
  @override
  final String? seed;
  @override
  final Path? path;
  @override
  final String? svgPath;
  @override
  final BlobCurves? curves;

  @override
  String toString() {
    return 'BlobData(edges: $edges, growth: $growth, size: $size, points: $points, seed: $seed, path: $path, svgPath: $svgPath, curves: $curves)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BlobData &&
            (identical(other.edges, edges) ||
                const DeepCollectionEquality().equals(other.edges, edges)) &&
            (identical(other.growth, growth) ||
                const DeepCollectionEquality().equals(other.growth, growth)) &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.points, points) ||
                const DeepCollectionEquality().equals(other.points, points)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.svgPath, svgPath) ||
                const DeepCollectionEquality()
                    .equals(other.svgPath, svgPath)) &&
            (identical(other.curves, curves) ||
                const DeepCollectionEquality().equals(other.curves, curves)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(edges) ^
      const DeepCollectionEquality().hash(growth) ^
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(points) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(svgPath) ^
      const DeepCollectionEquality().hash(curves);

  @JsonKey(ignore: true)
  @override
  _$BlobDataCopyWith<_BlobData> get copyWith =>
      __$BlobDataCopyWithImpl<_BlobData>(this, _$identity);
}

abstract class _BlobData implements BlobData {
  const factory _BlobData(
      {int edges,
      int growth,
      double? size,
      BlobPoints? points,
      String? seed,
      Path? path,
      String? svgPath,
      BlobCurves? curves}) = _$_BlobData;

  @override
  int get edges => throw _privateConstructorUsedError;
  @override
  int get growth => throw _privateConstructorUsedError;
  @override
  double? get size => throw _privateConstructorUsedError;
  @override
  BlobPoints? get points => throw _privateConstructorUsedError;
  @override
  String? get seed => throw _privateConstructorUsedError;
  @override
  Path? get path => throw _privateConstructorUsedError;
  @override
  String? get svgPath => throw _privateConstructorUsedError;
  @override
  BlobCurves? get curves => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BlobDataCopyWith<_BlobData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$BlobSeedTearOff {
  const _$BlobSeedTearOff();

  _BlobSeed call({int edges = 7, int growth = 4, required int seed}) {
    return _BlobSeed(
      edges: edges,
      growth: growth,
      seed: seed,
    );
  }
}

/// @nodoc
const $BlobSeed = _$BlobSeedTearOff();

/// @nodoc
mixin _$BlobSeed {
  int get edges => throw _privateConstructorUsedError;
  int get growth => throw _privateConstructorUsedError;
  int get seed => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlobSeedCopyWith<BlobSeed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlobSeedCopyWith<$Res> {
  factory $BlobSeedCopyWith(BlobSeed value, $Res Function(BlobSeed) then) =
      _$BlobSeedCopyWithImpl<$Res>;
  $Res call({int edges, int growth, int seed});
}

/// @nodoc
class _$BlobSeedCopyWithImpl<$Res> implements $BlobSeedCopyWith<$Res> {
  _$BlobSeedCopyWithImpl(this._value, this._then);

  final BlobSeed _value;
  // ignore: unused_field
  final $Res Function(BlobSeed) _then;

  @override
  $Res call({
    Object? edges = freezed,
    Object? growth = freezed,
    Object? seed = freezed,
  }) {
    return _then(_value.copyWith(
      edges: edges == freezed
          ? _value.edges
          : edges // ignore: cast_nullable_to_non_nullable
              as int,
      growth: growth == freezed
          ? _value.growth
          : growth // ignore: cast_nullable_to_non_nullable
              as int,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$BlobSeedCopyWith<$Res> implements $BlobSeedCopyWith<$Res> {
  factory _$BlobSeedCopyWith(_BlobSeed value, $Res Function(_BlobSeed) then) =
      __$BlobSeedCopyWithImpl<$Res>;
  @override
  $Res call({int edges, int growth, int seed});
}

/// @nodoc
class __$BlobSeedCopyWithImpl<$Res> extends _$BlobSeedCopyWithImpl<$Res>
    implements _$BlobSeedCopyWith<$Res> {
  __$BlobSeedCopyWithImpl(_BlobSeed _value, $Res Function(_BlobSeed) _then)
      : super(_value, (v) => _then(v as _BlobSeed));

  @override
  _BlobSeed get _value => super._value as _BlobSeed;

  @override
  $Res call({
    Object? edges = freezed,
    Object? growth = freezed,
    Object? seed = freezed,
  }) {
    return _then(_BlobSeed(
      edges: edges == freezed
          ? _value.edges
          : edges // ignore: cast_nullable_to_non_nullable
              as int,
      growth: growth == freezed
          ? _value.growth
          : growth // ignore: cast_nullable_to_non_nullable
              as int,
      seed: seed == freezed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_BlobSeed implements _BlobSeed {
  const _$_BlobSeed({this.edges = 7, this.growth = 4, required this.seed})
      : assert(edges >= 2 && edges <= 300),
        assert(growth >= 2 && growth <= 9);

  @JsonKey(defaultValue: 7)
  @override
  final int edges;
  @JsonKey(defaultValue: 4)
  @override
  final int growth;
  @override
  final int seed;

  @override
  String toString() {
    return 'BlobSeed(edges: $edges, growth: $growth, seed: $seed)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BlobSeed &&
            (identical(other.edges, edges) ||
                const DeepCollectionEquality().equals(other.edges, edges)) &&
            (identical(other.growth, growth) ||
                const DeepCollectionEquality().equals(other.growth, growth)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(edges) ^
      const DeepCollectionEquality().hash(growth) ^
      const DeepCollectionEquality().hash(seed);

  @JsonKey(ignore: true)
  @override
  _$BlobSeedCopyWith<_BlobSeed> get copyWith =>
      __$BlobSeedCopyWithImpl<_BlobSeed>(this, _$identity);
}

abstract class _BlobSeed implements BlobSeed {
  const factory _BlobSeed({int edges, int growth, required int seed}) =
      _$_BlobSeed;

  @override
  int get edges => throw _privateConstructorUsedError;
  @override
  int get growth => throw _privateConstructorUsedError;
  @override
  int get seed => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BlobSeedCopyWith<_BlobSeed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$BlobCurvesTearOff {
  const _$BlobCurvesTearOff();

  _BlobCurves call(
      {required Offset start,
      required List<List<double>> curves,
      required List<Offset> breakpoints}) {
    return _BlobCurves(
      start: start,
      curves: curves,
      breakpoints: breakpoints,
    );
  }
}

/// @nodoc
const $BlobCurves = _$BlobCurvesTearOff();

/// @nodoc
mixin _$BlobCurves {
  Offset get start => throw _privateConstructorUsedError;
  List<List<double>> get curves => throw _privateConstructorUsedError;
  List<Offset> get breakpoints => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlobCurvesCopyWith<BlobCurves> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlobCurvesCopyWith<$Res> {
  factory $BlobCurvesCopyWith(
          BlobCurves value, $Res Function(BlobCurves) then) =
      _$BlobCurvesCopyWithImpl<$Res>;
  $Res call(
      {Offset start, List<List<double>> curves, List<Offset> breakpoints});
}

/// @nodoc
class _$BlobCurvesCopyWithImpl<$Res> implements $BlobCurvesCopyWith<$Res> {
  _$BlobCurvesCopyWithImpl(this._value, this._then);

  final BlobCurves _value;
  // ignore: unused_field
  final $Res Function(BlobCurves) _then;

  @override
  $Res call({
    Object? start = freezed,
    Object? curves = freezed,
    Object? breakpoints = freezed,
  }) {
    return _then(_value.copyWith(
      start: start == freezed
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as Offset,
      curves: curves == freezed
          ? _value.curves
          : curves // ignore: cast_nullable_to_non_nullable
              as List<List<double>>,
      breakpoints: breakpoints == freezed
          ? _value.breakpoints
          : breakpoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
    ));
  }
}

/// @nodoc
abstract class _$BlobCurvesCopyWith<$Res> implements $BlobCurvesCopyWith<$Res> {
  factory _$BlobCurvesCopyWith(
          _BlobCurves value, $Res Function(_BlobCurves) then) =
      __$BlobCurvesCopyWithImpl<$Res>;
  @override
  $Res call(
      {Offset start, List<List<double>> curves, List<Offset> breakpoints});
}

/// @nodoc
class __$BlobCurvesCopyWithImpl<$Res> extends _$BlobCurvesCopyWithImpl<$Res>
    implements _$BlobCurvesCopyWith<$Res> {
  __$BlobCurvesCopyWithImpl(
      _BlobCurves _value, $Res Function(_BlobCurves) _then)
      : super(_value, (v) => _then(v as _BlobCurves));

  @override
  _BlobCurves get _value => super._value as _BlobCurves;

  @override
  $Res call({
    Object? start = freezed,
    Object? curves = freezed,
    Object? breakpoints = freezed,
  }) {
    return _then(_BlobCurves(
      start: start == freezed
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as Offset,
      curves: curves == freezed
          ? _value.curves
          : curves // ignore: cast_nullable_to_non_nullable
              as List<List<double>>,
      breakpoints: breakpoints == freezed
          ? _value.breakpoints
          : breakpoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
    ));
  }
}

/// @nodoc

class _$_BlobCurves implements _BlobCurves {
  const _$_BlobCurves(
      {required this.start, required this.curves, required this.breakpoints});

  @override
  final Offset start;
  @override
  final List<List<double>> curves;
  @override
  final List<Offset> breakpoints;

  @override
  String toString() {
    return 'BlobCurves(start: $start, curves: $curves, breakpoints: $breakpoints)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BlobCurves &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.curves, curves) ||
                const DeepCollectionEquality().equals(other.curves, curves)) &&
            (identical(other.breakpoints, breakpoints) ||
                const DeepCollectionEquality()
                    .equals(other.breakpoints, breakpoints)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(curves) ^
      const DeepCollectionEquality().hash(breakpoints);

  @JsonKey(ignore: true)
  @override
  _$BlobCurvesCopyWith<_BlobCurves> get copyWith =>
      __$BlobCurvesCopyWithImpl<_BlobCurves>(this, _$identity);
}

abstract class _BlobCurves implements BlobCurves {
  const factory _BlobCurves(
      {required Offset start,
      required List<List<double>> curves,
      required List<Offset> breakpoints}) = _$_BlobCurves;

  @override
  Offset get start => throw _privateConstructorUsedError;
  @override
  List<List<double>> get curves => throw _privateConstructorUsedError;
  @override
  List<Offset> get breakpoints => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BlobCurvesCopyWith<_BlobCurves> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$BlobStylesTearOff {
  const _$BlobStylesTearOff();

  _BlobStyles call(
      {Color? color,
      Shader? gradient,
      int? strokeWidth,
      BlobFillType? fillType}) {
    return _BlobStyles(
      color: color,
      gradient: gradient,
      strokeWidth: strokeWidth,
      fillType: fillType,
    );
  }
}

/// @nodoc
const $BlobStyles = _$BlobStylesTearOff();

/// @nodoc
mixin _$BlobStyles {
  Color? get color => throw _privateConstructorUsedError;
  Shader? get gradient => throw _privateConstructorUsedError;
  int? get strokeWidth => throw _privateConstructorUsedError;
  BlobFillType? get fillType => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlobStylesCopyWith<BlobStyles> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlobStylesCopyWith<$Res> {
  factory $BlobStylesCopyWith(
          BlobStyles value, $Res Function(BlobStyles) then) =
      _$BlobStylesCopyWithImpl<$Res>;
  $Res call(
      {Color? color,
      Shader? gradient,
      int? strokeWidth,
      BlobFillType? fillType});
}

/// @nodoc
class _$BlobStylesCopyWithImpl<$Res> implements $BlobStylesCopyWith<$Res> {
  _$BlobStylesCopyWithImpl(this._value, this._then);

  final BlobStyles _value;
  // ignore: unused_field
  final $Res Function(BlobStyles) _then;

  @override
  $Res call({
    Object? color = freezed,
    Object? gradient = freezed,
    Object? strokeWidth = freezed,
    Object? fillType = freezed,
  }) {
    return _then(_value.copyWith(
      color: color == freezed
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      gradient: gradient == freezed
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Shader?,
      strokeWidth: strokeWidth == freezed
          ? _value.strokeWidth
          : strokeWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      fillType: fillType == freezed
          ? _value.fillType
          : fillType // ignore: cast_nullable_to_non_nullable
              as BlobFillType?,
    ));
  }
}

/// @nodoc
abstract class _$BlobStylesCopyWith<$Res> implements $BlobStylesCopyWith<$Res> {
  factory _$BlobStylesCopyWith(
          _BlobStyles value, $Res Function(_BlobStyles) then) =
      __$BlobStylesCopyWithImpl<$Res>;
  @override
  $Res call(
      {Color? color,
      Shader? gradient,
      int? strokeWidth,
      BlobFillType? fillType});
}

/// @nodoc
class __$BlobStylesCopyWithImpl<$Res> extends _$BlobStylesCopyWithImpl<$Res>
    implements _$BlobStylesCopyWith<$Res> {
  __$BlobStylesCopyWithImpl(
      _BlobStyles _value, $Res Function(_BlobStyles) _then)
      : super(_value, (v) => _then(v as _BlobStyles));

  @override
  _BlobStyles get _value => super._value as _BlobStyles;

  @override
  $Res call({
    Object? color = freezed,
    Object? gradient = freezed,
    Object? strokeWidth = freezed,
    Object? fillType = freezed,
  }) {
    return _then(_BlobStyles(
      color: color == freezed
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      gradient: gradient == freezed
          ? _value.gradient
          : gradient // ignore: cast_nullable_to_non_nullable
              as Shader?,
      strokeWidth: strokeWidth == freezed
          ? _value.strokeWidth
          : strokeWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      fillType: fillType == freezed
          ? _value.fillType
          : fillType // ignore: cast_nullable_to_non_nullable
              as BlobFillType?,
    ));
  }
}

/// @nodoc

class _$_BlobStyles implements _BlobStyles {
  const _$_BlobStyles(
      {this.color, this.gradient, this.strokeWidth, this.fillType});

  @override
  final Color? color;
  @override
  final Shader? gradient;
  @override
  final int? strokeWidth;
  @override
  final BlobFillType? fillType;

  @override
  String toString() {
    return 'BlobStyles(color: $color, gradient: $gradient, strokeWidth: $strokeWidth, fillType: $fillType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BlobStyles &&
            (identical(other.color, color) ||
                const DeepCollectionEquality().equals(other.color, color)) &&
            (identical(other.gradient, gradient) ||
                const DeepCollectionEquality()
                    .equals(other.gradient, gradient)) &&
            (identical(other.strokeWidth, strokeWidth) ||
                const DeepCollectionEquality()
                    .equals(other.strokeWidth, strokeWidth)) &&
            (identical(other.fillType, fillType) ||
                const DeepCollectionEquality()
                    .equals(other.fillType, fillType)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(color) ^
      const DeepCollectionEquality().hash(gradient) ^
      const DeepCollectionEquality().hash(strokeWidth) ^
      const DeepCollectionEquality().hash(fillType);

  @JsonKey(ignore: true)
  @override
  _$BlobStylesCopyWith<_BlobStyles> get copyWith =>
      __$BlobStylesCopyWithImpl<_BlobStyles>(this, _$identity);
}

abstract class _BlobStyles implements BlobStyles {
  const factory _BlobStyles(
      {Color? color,
      Shader? gradient,
      int? strokeWidth,
      BlobFillType? fillType}) = _$_BlobStyles;

  @override
  Color? get color => throw _privateConstructorUsedError;
  @override
  Shader? get gradient => throw _privateConstructorUsedError;
  @override
  int? get strokeWidth => throw _privateConstructorUsedError;
  @override
  BlobFillType? get fillType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BlobStylesCopyWith<_BlobStyles> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$BlobPointsTearOff {
  const _$BlobPointsTearOff();

  _BlobPoints call(
      {required List<Offset> originPoints,
      required List<Offset> destPoints,
      required Offset center,
      required double innerRad,
      String? id}) {
    return _BlobPoints(
      originPoints: originPoints,
      destPoints: destPoints,
      center: center,
      innerRad: innerRad,
      id: id,
    );
  }
}

/// @nodoc
const $BlobPoints = _$BlobPointsTearOff();

/// @nodoc
mixin _$BlobPoints {
  List<Offset> get originPoints => throw _privateConstructorUsedError;
  List<Offset> get destPoints => throw _privateConstructorUsedError;
  Offset get center => throw _privateConstructorUsedError;
  double get innerRad => throw _privateConstructorUsedError;
  String? get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BlobPointsCopyWith<BlobPoints> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlobPointsCopyWith<$Res> {
  factory $BlobPointsCopyWith(
          BlobPoints value, $Res Function(BlobPoints) then) =
      _$BlobPointsCopyWithImpl<$Res>;
  $Res call(
      {List<Offset> originPoints,
      List<Offset> destPoints,
      Offset center,
      double innerRad,
      String? id});
}

/// @nodoc
class _$BlobPointsCopyWithImpl<$Res> implements $BlobPointsCopyWith<$Res> {
  _$BlobPointsCopyWithImpl(this._value, this._then);

  final BlobPoints _value;
  // ignore: unused_field
  final $Res Function(BlobPoints) _then;

  @override
  $Res call({
    Object? originPoints = freezed,
    Object? destPoints = freezed,
    Object? center = freezed,
    Object? innerRad = freezed,
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      originPoints: originPoints == freezed
          ? _value.originPoints
          : originPoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
      destPoints: destPoints == freezed
          ? _value.destPoints
          : destPoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
      center: center == freezed
          ? _value.center
          : center // ignore: cast_nullable_to_non_nullable
              as Offset,
      innerRad: innerRad == freezed
          ? _value.innerRad
          : innerRad // ignore: cast_nullable_to_non_nullable
              as double,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$BlobPointsCopyWith<$Res> implements $BlobPointsCopyWith<$Res> {
  factory _$BlobPointsCopyWith(
          _BlobPoints value, $Res Function(_BlobPoints) then) =
      __$BlobPointsCopyWithImpl<$Res>;
  @override
  $Res call(
      {List<Offset> originPoints,
      List<Offset> destPoints,
      Offset center,
      double innerRad,
      String? id});
}

/// @nodoc
class __$BlobPointsCopyWithImpl<$Res> extends _$BlobPointsCopyWithImpl<$Res>
    implements _$BlobPointsCopyWith<$Res> {
  __$BlobPointsCopyWithImpl(
      _BlobPoints _value, $Res Function(_BlobPoints) _then)
      : super(_value, (v) => _then(v as _BlobPoints));

  @override
  _BlobPoints get _value => super._value as _BlobPoints;

  @override
  $Res call({
    Object? originPoints = freezed,
    Object? destPoints = freezed,
    Object? center = freezed,
    Object? innerRad = freezed,
    Object? id = freezed,
  }) {
    return _then(_BlobPoints(
      originPoints: originPoints == freezed
          ? _value.originPoints
          : originPoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
      destPoints: destPoints == freezed
          ? _value.destPoints
          : destPoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>,
      center: center == freezed
          ? _value.center
          : center // ignore: cast_nullable_to_non_nullable
              as Offset,
      innerRad: innerRad == freezed
          ? _value.innerRad
          : innerRad // ignore: cast_nullable_to_non_nullable
              as double,
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_BlobPoints implements _BlobPoints {
  const _$_BlobPoints(
      {required this.originPoints,
      required this.destPoints,
      required this.center,
      required this.innerRad,
      this.id});

  @override
  final List<Offset> originPoints;
  @override
  final List<Offset> destPoints;
  @override
  final Offset center;
  @override
  final double innerRad;
  @override
  final String? id;

  @override
  String toString() {
    return 'BlobPoints(originPoints: $originPoints, destPoints: $destPoints, center: $center, innerRad: $innerRad, id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _BlobPoints &&
            (identical(other.originPoints, originPoints) ||
                const DeepCollectionEquality()
                    .equals(other.originPoints, originPoints)) &&
            (identical(other.destPoints, destPoints) ||
                const DeepCollectionEquality()
                    .equals(other.destPoints, destPoints)) &&
            (identical(other.center, center) ||
                const DeepCollectionEquality().equals(other.center, center)) &&
            (identical(other.innerRad, innerRad) ||
                const DeepCollectionEquality()
                    .equals(other.innerRad, innerRad)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(originPoints) ^
      const DeepCollectionEquality().hash(destPoints) ^
      const DeepCollectionEquality().hash(center) ^
      const DeepCollectionEquality().hash(innerRad) ^
      const DeepCollectionEquality().hash(id);

  @JsonKey(ignore: true)
  @override
  _$BlobPointsCopyWith<_BlobPoints> get copyWith =>
      __$BlobPointsCopyWithImpl<_BlobPoints>(this, _$identity);
}

abstract class _BlobPoints implements BlobPoints {
  const factory _BlobPoints(
      {required List<Offset> originPoints,
      required List<Offset> destPoints,
      required Offset center,
      required double innerRad,
      String? id}) = _$_BlobPoints;

  @override
  List<Offset> get originPoints => throw _privateConstructorUsedError;
  @override
  List<Offset> get destPoints => throw _privateConstructorUsedError;
  @override
  Offset get center => throw _privateConstructorUsedError;
  @override
  double get innerRad => throw _privateConstructorUsedError;
  @override
  String? get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$BlobPointsCopyWith<_BlobPoints> get copyWith =>
      throw _privateConstructorUsedError;
}
